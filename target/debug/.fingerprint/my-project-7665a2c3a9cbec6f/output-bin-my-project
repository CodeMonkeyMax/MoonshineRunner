{"message":"unused import: `card::Card`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":254,"byte_end":264,"line_start":5,"line_end":5,"column_start":73,"column_end":83,"is_primary":true,"text":[{"text":"use lib::{car::Car, player::Player, route::Route, stat::Stat, sutil::*, card::Card};","highlight_start":73,"highlight_end":83}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_imports)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":252,"byte_end":264,"line_start":5,"line_end":5,"column_start":71,"column_end":83,"is_primary":true,"text":[{"text":"use lib::{car::Car, player::Player, route::Route, stat::Stat, sutil::*, card::Card};","highlight_start":71,"highlight_end":83}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `card::Card`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:5:73\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m5\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse lib::{car::Car, player::Player, route::Route, stat::Stat, sutil::*, card::Card};\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                                                        \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_imports)]` on by default\u001b[0m\n\n"}
{"message":"unused import: `write`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":292,"byte_end":297,"line_start":7,"line_end":7,"column_start":11,"column_end":16,"is_primary":true,"text":[{"text":"use std::{write, io::Write, thread, time::Duration};","highlight_start":11,"highlight_end":16}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the unused import","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":292,"byte_end":299,"line_start":7,"line_end":7,"column_start":11,"column_end":18,"is_primary":true,"text":[{"text":"use std::{write, io::Write, thread, time::Duration};","highlight_start":11,"highlight_end":18}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `write`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:7:11\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m7\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse std::{write, io::Write, thread, time::Duration};\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m          \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^\u001b[0m\n\n"}
{"message":"unused import: `core::fmt::Display`","code":{"code":"unused_imports","explanation":null},"level":"warning","spans":[{"file_name":"src/lib/card.rs","byte_start":4,"byte_end":22,"line_start":1,"line_end":1,"column_start":5,"column_end":23,"is_primary":true,"text":[{"text":"use core::fmt::Display;","highlight_start":5,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"remove the whole `use` item","code":null,"level":"help","spans":[{"file_name":"src/lib/card.rs","byte_start":0,"byte_end":23,"line_start":1,"line_end":1,"column_start":1,"column_end":24,"is_primary":true,"text":[{"text":"use core::fmt::Display;","highlight_start":1,"highlight_end":24}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused import: `core::fmt::Display`\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/card.rs:1:5\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m1\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0muse core::fmt::Display;\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^^^^^^^^^\u001b[0m\n\n"}
{"message":"unreachable pattern","code":{"code":"unreachable_patterns","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":16871,"byte_end":16872,"line_start":494,"line_end":494,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            _ => {","highlight_start":13,"highlight_end":14}],"label":"unreachable pattern","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":16788,"byte_end":16789,"line_start":491,"line_end":491,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"            c => {","highlight_start":13,"highlight_end":14}],"label":"matches any value","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unreachable_patterns)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unreachable pattern\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:494:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m491\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            c => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmatches any value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m494\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            _ => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33munreachable pattern\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unreachable_patterns)]` on by default\u001b[0m\n\n"}
{"message":"unreachable pattern","code":{"code":"unreachable_patterns","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":18957,"byte_end":18958,"line_start":548,"line_end":548,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"            _ => {","highlight_start":13,"highlight_end":14}],"label":"unreachable pattern","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/main.rs","byte_start":18874,"byte_end":18875,"line_start":545,"line_end":545,"column_start":13,"column_end":14,"is_primary":false,"text":[{"text":"            c => {","highlight_start":13,"highlight_end":14}],"label":"matches any value","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unreachable pattern\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:548:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m545\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            c => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mmatches any value\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m548\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            _ => {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33munreachable pattern\u001b[0m\n\n"}
{"message":"unused variable: `j`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":3507,"byte_end":3508,"line_start":111,"line_end":111,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"        for j in 0..i {","highlight_start":13,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_variables)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":3507,"byte_end":3508,"line_start":111,"line_end":111,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"        for j in 0..i {","highlight_start":13,"highlight_end":14}],"label":null,"suggested_replacement":"_j","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `j`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:111:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m111\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        for j in 0..i {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_j`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_variables)]` on by default\u001b[0m\n\n"}
{"message":"unused variable: `j`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":3565,"byte_end":3566,"line_start":114,"line_end":114,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"        for j in i..36 - 1 {","highlight_start":13,"highlight_end":14}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":3565,"byte_end":3566,"line_start":114,"line_end":114,"column_start":13,"column_end":14,"is_primary":true,"text":[{"text":"        for j in i..36 - 1 {","highlight_start":13,"highlight_end":14}],"label":null,"suggested_replacement":"_j","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `j`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:114:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m114\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        for j in i..36 - 1 {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_j`\u001b[0m\n\n"}
{"message":"value assigned to `mult` is never read","code":{"code":"unused_assignments","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":9882,"byte_end":9886,"line_start":301,"line_end":301,"column_start":13,"column_end":17,"is_primary":true,"text":[{"text":"    let mut mult: f64 = 1.0;","highlight_start":13,"highlight_end":17}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_assignments)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"maybe it is overwritten before being read?","code":null,"level":"help","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: value assigned to `mult` is never read\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:301:13\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m301\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut mult: f64 = 1.0;\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_assignments)]` on by default\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mhelp\u001b[0m\u001b[0m: maybe it is overwritten before being read?\u001b[0m\n\n"}
{"message":"unused variable: `i`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/lib/card.rs","byte_start":918,"byte_end":919,"line_start":40,"line_end":40,"column_start":7,"column_end":8,"is_primary":true,"text":[{"text":"\t\tfor i in 1..self.cols {","highlight_start":7,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/lib/card.rs","byte_start":918,"byte_end":919,"line_start":40,"line_end":40,"column_start":7,"column_end":8,"is_primary":true,"text":[{"text":"\t\tfor i in 1..self.cols {","highlight_start":7,"highlight_end":8}],"label":null,"suggested_replacement":"_i","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `i`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/card.rs:40:7\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m40\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        for i in 1..self.cols {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_i`\u001b[0m\n\n"}
{"message":"unused variable: `i`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/lib/card.rs","byte_start":1251,"byte_end":1252,"line_start":52,"line_end":52,"column_start":7,"column_end":8,"is_primary":true,"text":[{"text":"\t\tfor i in 1..self.cols {","highlight_start":7,"highlight_end":8}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/lib/card.rs","byte_start":1251,"byte_end":1252,"line_start":52,"line_end":52,"column_start":7,"column_end":8,"is_primary":true,"text":[{"text":"\t\tfor i in 1..self.cols {","highlight_start":7,"highlight_end":8}],"label":null,"suggested_replacement":"_i","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `i`\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/card.rs:52:7\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m52\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        for i in 1..self.cols {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m            \u001b[0m\u001b[0m\u001b[1m\u001b[33m^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_i`\u001b[0m\n\n"}
{"message":"unused variable: `player`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/lib/sutil.rs","byte_start":7272,"byte_end":7278,"line_start":227,"line_end":227,"column_start":25,"column_end":31,"is_primary":true,"text":[{"text":"pub fn print_brew_stage(player: &mut crate::Player) {","highlight_start":25,"highlight_end":31}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/lib/sutil.rs","byte_start":7272,"byte_end":7278,"line_start":227,"line_end":227,"column_start":25,"column_end":31,"is_primary":true,"text":[{"text":"pub fn print_brew_stage(player: &mut crate::Player) {","highlight_start":25,"highlight_end":31}],"label":null,"suggested_replacement":"_player","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `player`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/sutil.rs:227:25\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m227\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn print_brew_stage(player: &mut crate::Player) {\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                        \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_player`\u001b[0m\n\n"}
{"message":"unused variable: `player`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/lib/sutil.rs","byte_start":8126,"byte_end":8132,"line_start":256,"line_end":256,"column_start":27,"column_end":33,"is_primary":true,"text":[{"text":"pub fn print_barter_stage(player: &mut crate::Player) {}","highlight_start":27,"highlight_end":33}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/lib/sutil.rs","byte_start":8126,"byte_end":8132,"line_start":256,"line_end":256,"column_start":27,"column_end":33,"is_primary":true,"text":[{"text":"pub fn print_barter_stage(player: &mut crate::Player) {}","highlight_start":27,"highlight_end":33}],"label":null,"suggested_replacement":"_player","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `player`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/sutil.rs:256:27\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m256\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn print_barter_stage(player: &mut crate::Player) {}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_player`\u001b[0m\n\n"}
{"message":"unused variable: `player`","code":{"code":"unused_variables","explanation":null},"level":"warning","spans":[{"file_name":"src/lib/sutil.rs","byte_start":8180,"byte_end":8186,"line_start":257,"line_end":257,"column_start":24,"column_end":30,"is_primary":true,"text":[{"text":"pub fn print_buy_stage(player: &mut crate::Player) {}","highlight_start":24,"highlight_end":30}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"if this is intentional, prefix it with an underscore","code":null,"level":"help","spans":[{"file_name":"src/lib/sutil.rs","byte_start":8180,"byte_end":8186,"line_start":257,"line_end":257,"column_start":24,"column_end":30,"is_primary":true,"text":[{"text":"pub fn print_buy_stage(player: &mut crate::Player) {}","highlight_start":24,"highlight_end":30}],"label":null,"suggested_replacement":"_player","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: unused variable: `player`\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/sutil.rs:257:24\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m257\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub fn print_buy_stage(player: &mut crate::Player) {}\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                       \u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[33mhelp: if this is intentional, prefix it with an underscore: `_player`\u001b[0m\n\n"}
{"message":"allocations are not allowed in constants","code":{"code":"E0010","explanation":"The value of statics and constants must be known at compile time, and they live\nfor the entire lifetime of a program. Creating a boxed value allocates memory on\nthe heap at runtime, and therefore cannot be done at compile time.\n\nErroneous code example:\n\n```compile_fail,E0010\n#![feature(box_syntax)]\n\nconst CON : Box<i32> = box 0;\n```\n"},"level":"error","spans":[{"file_name":"/build/rustc-1.64.0-src/library/alloc/src/macros.rs","byte_start":1772,"byte_end":1806,"line_start":52,"line_end":52,"column_start":13,"column_end":47,"is_primary":true,"text":[],"label":"allocation not allowed in constants","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib/card.rs","byte_start":154,"byte_end":163,"line_start":9,"line_end":9,"column_start":45,"column_end":54,"is_primary":false,"text":[{"text":"pub const SMALL_TEST_CARD: Card = Card::new(vec![\" \"]);","highlight_start":45,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"vec!","def_site_span":{"file_name":"/build/rustc-1.64.0-src/library/alloc/src/macros.rs","byte_start":1447,"byte_end":1463,"line_start":42,"line_end":42,"column_start":1,"column_end":17,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0010]\u001b[0m\u001b[0m\u001b[1m: allocations are not allowed in constants\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/card.rs:9:45\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub const SMALL_TEST_CARD: Card = Card::new(vec![\" \"]);\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mallocation not allowed in constants\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"cannot call non-const fn `std::slice::<impl [&str]>::into_vec::<std::alloc::Global>` in constants","code":{"code":"E0015","explanation":"A constant item was initialized with something that is not a constant\nexpression.\n\nErroneous code example:\n\n```compile_fail,E0015\nfn create_some() -> Option<u8> {\n    Some(1)\n}\n\nconst FOO: Option<u8> = create_some(); // error!\n```\n\nThe only functions that can be called in static or constant expressions are\n`const` functions, and struct/enum constructors.\n\nTo fix this error, you can declare `create_some` as a constant function:\n\n```\nconst fn create_some() -> Option<u8> { // declared as a const function\n    Some(1)\n}\n\nconst FOO: Option<u8> = create_some(); // ok!\n\n// These are also working:\nstruct Bar {\n    x: u8,\n}\n\nconst OTHER_FOO: Option<u8> = Some(1);\nconst BAR: Bar = Bar {x: 1};\n```\n"},"level":"error","spans":[{"file_name":"/build/rustc-1.64.0-src/library/alloc/src/macros.rs","byte_start":1718,"byte_end":1816,"line_start":50,"line_end":53,"column_start":36,"column_end":10,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib/card.rs","byte_start":154,"byte_end":163,"line_start":9,"line_end":9,"column_start":45,"column_end":54,"is_primary":false,"text":[{"text":"pub const SMALL_TEST_CARD: Card = Card::new(vec![\" \"]);","highlight_start":45,"highlight_end":54}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"vec!","def_site_span":{"file_name":"/build/rustc-1.64.0-src/library/alloc/src/macros.rs","byte_start":1447,"byte_end":1463,"line_start":42,"line_end":42,"column_start":1,"column_end":17,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"calls in constants are limited to constant functions, tuple structs and tuple variants","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0015]\u001b[0m\u001b[0m\u001b[1m: cannot call non-const fn `std::slice::<impl [&str]>::into_vec::<std::alloc::Global>` in constants\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/card.rs:9:45\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub const SMALL_TEST_CARD: Card = Card::new(vec![\" \"]);\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: calls in constants are limited to constant functions, tuple structs and tuple variants\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"cannot call non-const fn `Card::new` in constants","code":{"code":"E0015","explanation":"A constant item was initialized with something that is not a constant\nexpression.\n\nErroneous code example:\n\n```compile_fail,E0015\nfn create_some() -> Option<u8> {\n    Some(1)\n}\n\nconst FOO: Option<u8> = create_some(); // error!\n```\n\nThe only functions that can be called in static or constant expressions are\n`const` functions, and struct/enum constructors.\n\nTo fix this error, you can declare `create_some` as a constant function:\n\n```\nconst fn create_some() -> Option<u8> { // declared as a const function\n    Some(1)\n}\n\nconst FOO: Option<u8> = create_some(); // ok!\n\n// These are also working:\nstruct Bar {\n    x: u8,\n}\n\nconst OTHER_FOO: Option<u8> = Some(1);\nconst BAR: Bar = Bar {x: 1};\n```\n"},"level":"error","spans":[{"file_name":"src/lib/card.rs","byte_start":144,"byte_end":164,"line_start":9,"line_end":9,"column_start":35,"column_end":55,"is_primary":true,"text":[{"text":"pub const SMALL_TEST_CARD: Card = Card::new(vec![\" \"]);","highlight_start":35,"highlight_end":55}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"calls in constants are limited to constant functions, tuple structs and tuple variants","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0015]\u001b[0m\u001b[0m\u001b[1m: cannot call non-const fn `Card::new` in constants\u001b[0m\n\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/card.rs:9:35\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m9\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub const SMALL_TEST_CARD: Card = Card::new(vec![\" \"]);\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: calls in constants are limited to constant functions, tuple structs and tuple variants\u001b[0m\n\n"}
{"message":"allocations are not allowed in constants","code":{"code":"E0010","explanation":"The value of statics and constants must be known at compile time, and they live\nfor the entire lifetime of a program. Creating a boxed value allocates memory on\nthe heap at runtime, and therefore cannot be done at compile time.\n\nErroneous code example:\n\n```compile_fail,E0010\n#![feature(box_syntax)]\n\nconst CON : Box<i32> = box 0;\n```\n"},"level":"error","spans":[{"file_name":"/build/rustc-1.64.0-src/library/alloc/src/macros.rs","byte_start":1772,"byte_end":1806,"line_start":52,"line_end":52,"column_start":13,"column_end":47,"is_primary":true,"text":[],"label":"allocation not allowed in constants","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib/card.rs","byte_start":211,"byte_end":227,"line_start":10,"line_end":10,"column_start":46,"column_end":62,"is_primary":false,"text":[{"text":"pub const MEDIUM_TEST_CARD: Card = Card::new(vec![\"  \", \"  \"]);","highlight_start":46,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"vec!","def_site_span":{"file_name":"/build/rustc-1.64.0-src/library/alloc/src/macros.rs","byte_start":1447,"byte_end":1463,"line_start":42,"line_end":42,"column_start":1,"column_end":17,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0010]\u001b[0m\u001b[0m\u001b[1m: allocations are not allowed in constants\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/card.rs:10:46\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub const MEDIUM_TEST_CARD: Card = Card::new(vec![\"  \", \"  \"]);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mallocation not allowed in constants\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"cannot call non-const fn `std::slice::<impl [&str]>::into_vec::<std::alloc::Global>` in constants","code":{"code":"E0015","explanation":"A constant item was initialized with something that is not a constant\nexpression.\n\nErroneous code example:\n\n```compile_fail,E0015\nfn create_some() -> Option<u8> {\n    Some(1)\n}\n\nconst FOO: Option<u8> = create_some(); // error!\n```\n\nThe only functions that can be called in static or constant expressions are\n`const` functions, and struct/enum constructors.\n\nTo fix this error, you can declare `create_some` as a constant function:\n\n```\nconst fn create_some() -> Option<u8> { // declared as a const function\n    Some(1)\n}\n\nconst FOO: Option<u8> = create_some(); // ok!\n\n// These are also working:\nstruct Bar {\n    x: u8,\n}\n\nconst OTHER_FOO: Option<u8> = Some(1);\nconst BAR: Bar = Bar {x: 1};\n```\n"},"level":"error","spans":[{"file_name":"/build/rustc-1.64.0-src/library/alloc/src/macros.rs","byte_start":1718,"byte_end":1816,"line_start":50,"line_end":53,"column_start":36,"column_end":10,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib/card.rs","byte_start":211,"byte_end":227,"line_start":10,"line_end":10,"column_start":46,"column_end":62,"is_primary":false,"text":[{"text":"pub const MEDIUM_TEST_CARD: Card = Card::new(vec![\"  \", \"  \"]);","highlight_start":46,"highlight_end":62}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"vec!","def_site_span":{"file_name":"/build/rustc-1.64.0-src/library/alloc/src/macros.rs","byte_start":1447,"byte_end":1463,"line_start":42,"line_end":42,"column_start":1,"column_end":17,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"calls in constants are limited to constant functions, tuple structs and tuple variants","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0015]\u001b[0m\u001b[0m\u001b[1m: cannot call non-const fn `std::slice::<impl [&str]>::into_vec::<std::alloc::Global>` in constants\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/card.rs:10:46\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub const MEDIUM_TEST_CARD: Card = Card::new(vec![\"  \", \"  \"]);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: calls in constants are limited to constant functions, tuple structs and tuple variants\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"cannot call non-const fn `Card::new` in constants","code":{"code":"E0015","explanation":"A constant item was initialized with something that is not a constant\nexpression.\n\nErroneous code example:\n\n```compile_fail,E0015\nfn create_some() -> Option<u8> {\n    Some(1)\n}\n\nconst FOO: Option<u8> = create_some(); // error!\n```\n\nThe only functions that can be called in static or constant expressions are\n`const` functions, and struct/enum constructors.\n\nTo fix this error, you can declare `create_some` as a constant function:\n\n```\nconst fn create_some() -> Option<u8> { // declared as a const function\n    Some(1)\n}\n\nconst FOO: Option<u8> = create_some(); // ok!\n\n// These are also working:\nstruct Bar {\n    x: u8,\n}\n\nconst OTHER_FOO: Option<u8> = Some(1);\nconst BAR: Bar = Bar {x: 1};\n```\n"},"level":"error","spans":[{"file_name":"src/lib/card.rs","byte_start":201,"byte_end":228,"line_start":10,"line_end":10,"column_start":36,"column_end":63,"is_primary":true,"text":[{"text":"pub const MEDIUM_TEST_CARD: Card = Card::new(vec![\"  \", \"  \"]);","highlight_start":36,"highlight_end":63}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"calls in constants are limited to constant functions, tuple structs and tuple variants","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0015]\u001b[0m\u001b[0m\u001b[1m: cannot call non-const fn `Card::new` in constants\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/card.rs:10:36\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m10\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub const MEDIUM_TEST_CARD: Card = Card::new(vec![\"  \", \"  \"]);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: calls in constants are limited to constant functions, tuple structs and tuple variants\u001b[0m\n\n"}
{"message":"allocations are not allowed in constants","code":{"code":"E0010","explanation":"The value of statics and constants must be known at compile time, and they live\nfor the entire lifetime of a program. Creating a boxed value allocates memory on\nthe heap at runtime, and therefore cannot be done at compile time.\n\nErroneous code example:\n\n```compile_fail,E0010\n#![feature(box_syntax)]\n\nconst CON : Box<i32> = box 0;\n```\n"},"level":"error","spans":[{"file_name":"/build/rustc-1.64.0-src/library/alloc/src/macros.rs","byte_start":1772,"byte_end":1806,"line_start":52,"line_end":52,"column_start":13,"column_end":47,"is_primary":true,"text":[],"label":"allocation not allowed in constants","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib/card.rs","byte_start":274,"byte_end":299,"line_start":11,"line_end":11,"column_start":45,"column_end":70,"is_primary":false,"text":[{"text":"pub const LARGE_TEST_CARD: Card = Card::new(vec![\"   \", \"   \", \"   \"]);","highlight_start":45,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"vec!","def_site_span":{"file_name":"/build/rustc-1.64.0-src/library/alloc/src/macros.rs","byte_start":1447,"byte_end":1463,"line_start":42,"line_end":42,"column_start":1,"column_end":17,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0010]\u001b[0m\u001b[0m\u001b[1m: allocations are not allowed in constants\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/card.rs:11:45\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub const LARGE_TEST_CARD: Card = Card::new(vec![\"   \", \"   \", \"   \"]);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mallocation not allowed in constants\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"cannot call non-const fn `std::slice::<impl [&str]>::into_vec::<std::alloc::Global>` in constants","code":{"code":"E0015","explanation":"A constant item was initialized with something that is not a constant\nexpression.\n\nErroneous code example:\n\n```compile_fail,E0015\nfn create_some() -> Option<u8> {\n    Some(1)\n}\n\nconst FOO: Option<u8> = create_some(); // error!\n```\n\nThe only functions that can be called in static or constant expressions are\n`const` functions, and struct/enum constructors.\n\nTo fix this error, you can declare `create_some` as a constant function:\n\n```\nconst fn create_some() -> Option<u8> { // declared as a const function\n    Some(1)\n}\n\nconst FOO: Option<u8> = create_some(); // ok!\n\n// These are also working:\nstruct Bar {\n    x: u8,\n}\n\nconst OTHER_FOO: Option<u8> = Some(1);\nconst BAR: Bar = Bar {x: 1};\n```\n"},"level":"error","spans":[{"file_name":"/build/rustc-1.64.0-src/library/alloc/src/macros.rs","byte_start":1718,"byte_end":1816,"line_start":50,"line_end":53,"column_start":36,"column_end":10,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib/card.rs","byte_start":274,"byte_end":299,"line_start":11,"line_end":11,"column_start":45,"column_end":70,"is_primary":false,"text":[{"text":"pub const LARGE_TEST_CARD: Card = Card::new(vec![\"   \", \"   \", \"   \"]);","highlight_start":45,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"vec!","def_site_span":{"file_name":"/build/rustc-1.64.0-src/library/alloc/src/macros.rs","byte_start":1447,"byte_end":1463,"line_start":42,"line_end":42,"column_start":1,"column_end":17,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"calls in constants are limited to constant functions, tuple structs and tuple variants","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0015]\u001b[0m\u001b[0m\u001b[1m: cannot call non-const fn `std::slice::<impl [&str]>::into_vec::<std::alloc::Global>` in constants\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/card.rs:11:45\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub const LARGE_TEST_CARD: Card = Card::new(vec![\"   \", \"   \", \"   \"]);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                            \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: calls in constants are limited to constant functions, tuple structs and tuple variants\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"cannot call non-const fn `Card::new` in constants","code":{"code":"E0015","explanation":"A constant item was initialized with something that is not a constant\nexpression.\n\nErroneous code example:\n\n```compile_fail,E0015\nfn create_some() -> Option<u8> {\n    Some(1)\n}\n\nconst FOO: Option<u8> = create_some(); // error!\n```\n\nThe only functions that can be called in static or constant expressions are\n`const` functions, and struct/enum constructors.\n\nTo fix this error, you can declare `create_some` as a constant function:\n\n```\nconst fn create_some() -> Option<u8> { // declared as a const function\n    Some(1)\n}\n\nconst FOO: Option<u8> = create_some(); // ok!\n\n// These are also working:\nstruct Bar {\n    x: u8,\n}\n\nconst OTHER_FOO: Option<u8> = Some(1);\nconst BAR: Bar = Bar {x: 1};\n```\n"},"level":"error","spans":[{"file_name":"src/lib/card.rs","byte_start":264,"byte_end":300,"line_start":11,"line_end":11,"column_start":35,"column_end":71,"is_primary":true,"text":[{"text":"pub const LARGE_TEST_CARD: Card = Card::new(vec![\"   \", \"   \", \"   \"]);","highlight_start":35,"highlight_end":71}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"calls in constants are limited to constant functions, tuple structs and tuple variants","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0015]\u001b[0m\u001b[0m\u001b[1m: cannot call non-const fn `Card::new` in constants\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/card.rs:11:35\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m11\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub const LARGE_TEST_CARD: Card = Card::new(vec![\"   \", \"   \", \"   \"]);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: calls in constants are limited to constant functions, tuple structs and tuple variants\u001b[0m\n\n"}
{"message":"allocations are not allowed in constants","code":{"code":"E0010","explanation":"The value of statics and constants must be known at compile time, and they live\nfor the entire lifetime of a program. Creating a boxed value allocates memory on\nthe heap at runtime, and therefore cannot be done at compile time.\n\nErroneous code example:\n\n```compile_fail,E0010\n#![feature(box_syntax)]\n\nconst CON : Box<i32> = box 0;\n```\n"},"level":"error","spans":[{"file_name":"/build/rustc-1.64.0-src/library/alloc/src/macros.rs","byte_start":1772,"byte_end":1806,"line_start":52,"line_end":52,"column_start":13,"column_end":47,"is_primary":true,"text":[],"label":"allocation not allowed in constants","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib/card.rs","byte_start":347,"byte_end":371,"line_start":12,"line_end":12,"column_start":46,"column_end":70,"is_primary":false,"text":[{"text":"pub const JAGGED_TEST_CARD: Card = Card::new(vec![\"   \", \"   \", \"  \"]);","highlight_start":46,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"vec!","def_site_span":{"file_name":"/build/rustc-1.64.0-src/library/alloc/src/macros.rs","byte_start":1447,"byte_end":1463,"line_start":42,"line_end":42,"column_start":1,"column_end":17,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0010]\u001b[0m\u001b[0m\u001b[1m: allocations are not allowed in constants\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/card.rs:12:46\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m12\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub const JAGGED_TEST_CARD: Card = Card::new(vec![\"   \", \"   \", \"  \"]);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mallocation not allowed in constants\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"cannot call non-const fn `std::slice::<impl [&str]>::into_vec::<std::alloc::Global>` in constants","code":{"code":"E0015","explanation":"A constant item was initialized with something that is not a constant\nexpression.\n\nErroneous code example:\n\n```compile_fail,E0015\nfn create_some() -> Option<u8> {\n    Some(1)\n}\n\nconst FOO: Option<u8> = create_some(); // error!\n```\n\nThe only functions that can be called in static or constant expressions are\n`const` functions, and struct/enum constructors.\n\nTo fix this error, you can declare `create_some` as a constant function:\n\n```\nconst fn create_some() -> Option<u8> { // declared as a const function\n    Some(1)\n}\n\nconst FOO: Option<u8> = create_some(); // ok!\n\n// These are also working:\nstruct Bar {\n    x: u8,\n}\n\nconst OTHER_FOO: Option<u8> = Some(1);\nconst BAR: Bar = Bar {x: 1};\n```\n"},"level":"error","spans":[{"file_name":"/build/rustc-1.64.0-src/library/alloc/src/macros.rs","byte_start":1718,"byte_end":1816,"line_start":50,"line_end":53,"column_start":36,"column_end":10,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib/card.rs","byte_start":347,"byte_end":371,"line_start":12,"line_end":12,"column_start":46,"column_end":70,"is_primary":false,"text":[{"text":"pub const JAGGED_TEST_CARD: Card = Card::new(vec![\"   \", \"   \", \"  \"]);","highlight_start":46,"highlight_end":70}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"vec!","def_site_span":{"file_name":"/build/rustc-1.64.0-src/library/alloc/src/macros.rs","byte_start":1447,"byte_end":1463,"line_start":42,"line_end":42,"column_start":1,"column_end":17,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"calls in constants are limited to constant functions, tuple structs and tuple variants","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0015]\u001b[0m\u001b[0m\u001b[1m: cannot call non-const fn `std::slice::<impl [&str]>::into_vec::<std::alloc::Global>` in constants\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/card.rs:12:46\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m12\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub const JAGGED_TEST_CARD: Card = Card::new(vec![\"   \", \"   \", \"  \"]);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                             \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: calls in constants are limited to constant functions, tuple structs and tuple variants\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"cannot call non-const fn `Card::new` in constants","code":{"code":"E0015","explanation":"A constant item was initialized with something that is not a constant\nexpression.\n\nErroneous code example:\n\n```compile_fail,E0015\nfn create_some() -> Option<u8> {\n    Some(1)\n}\n\nconst FOO: Option<u8> = create_some(); // error!\n```\n\nThe only functions that can be called in static or constant expressions are\n`const` functions, and struct/enum constructors.\n\nTo fix this error, you can declare `create_some` as a constant function:\n\n```\nconst fn create_some() -> Option<u8> { // declared as a const function\n    Some(1)\n}\n\nconst FOO: Option<u8> = create_some(); // ok!\n\n// These are also working:\nstruct Bar {\n    x: u8,\n}\n\nconst OTHER_FOO: Option<u8> = Some(1);\nconst BAR: Bar = Bar {x: 1};\n```\n"},"level":"error","spans":[{"file_name":"src/lib/card.rs","byte_start":337,"byte_end":372,"line_start":12,"line_end":12,"column_start":36,"column_end":71,"is_primary":true,"text":[{"text":"pub const JAGGED_TEST_CARD: Card = Card::new(vec![\"   \", \"   \", \"  \"]);","highlight_start":36,"highlight_end":71}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"calls in constants are limited to constant functions, tuple structs and tuple variants","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0015]\u001b[0m\u001b[0m\u001b[1m: cannot call non-const fn `Card::new` in constants\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/card.rs:12:36\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m12\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0mpub const JAGGED_TEST_CARD: Card = Card::new(vec![\"   \", \"   \", \"  \"]);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                                   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: calls in constants are limited to constant functions, tuple structs and tuple variants\u001b[0m\n\n"}
{"message":"allocations are not allowed in constants","code":{"code":"E0010","explanation":"The value of statics and constants must be known at compile time, and they live\nfor the entire lifetime of a program. Creating a boxed value allocates memory on\nthe heap at runtime, and therefore cannot be done at compile time.\n\nErroneous code example:\n\n```compile_fail,E0010\n#![feature(box_syntax)]\n\nconst CON : Box<i32> = box 0;\n```\n"},"level":"error","spans":[{"file_name":"/build/rustc-1.64.0-src/library/alloc/src/macros.rs","byte_start":1772,"byte_end":1806,"line_start":52,"line_end":52,"column_start":13,"column_end":47,"is_primary":true,"text":[],"label":"allocation not allowed in constants","suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib/card.rs","byte_start":410,"byte_end":526,"line_start":13,"line_end":18,"column_start":37,"column_end":2,"is_primary":false,"text":[{"text":"pub const BIG_RIG: Card = Card::new(vec![","highlight_start":37,"highlight_end":42},{"text":"\t\"         /-/--|\t\t\t\",","highlight_start":1,"highlight_end":23},{"text":"\t\"\t /^\\\\---/_/| +|\t\t\t\",","highlight_start":1,"highlight_end":24},{"text":"\t\" *|#|*/-\\\\__|__|______===_\",","highlight_start":1,"highlight_end":31},{"text":"\t\" ====((O)-----)_)_)((O)(O)\",","highlight_start":1,"highlight_end":31},{"text":"]);","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"vec!","def_site_span":{"file_name":"/build/rustc-1.64.0-src/library/alloc/src/macros.rs","byte_start":1447,"byte_end":1463,"line_start":42,"line_end":42,"column_start":1,"column_end":17,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0010]\u001b[0m\u001b[0m\u001b[1m: allocations are not allowed in constants\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/card.rs:13:37\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0mpub const BIG_RIG: Card = Card::new(vec![\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m_____________________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m14\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \"         /-/--|            \",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \"     /^\\\\---/_/| +|            \",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \" *|#|*/-\\\\__|__|______===_\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \" ====((O)-----)_)_)((O)(O)\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m]);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9mallocation not allowed in constants\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"cannot call non-const fn `std::slice::<impl [&str]>::into_vec::<std::alloc::Global>` in constants","code":{"code":"E0015","explanation":"A constant item was initialized with something that is not a constant\nexpression.\n\nErroneous code example:\n\n```compile_fail,E0015\nfn create_some() -> Option<u8> {\n    Some(1)\n}\n\nconst FOO: Option<u8> = create_some(); // error!\n```\n\nThe only functions that can be called in static or constant expressions are\n`const` functions, and struct/enum constructors.\n\nTo fix this error, you can declare `create_some` as a constant function:\n\n```\nconst fn create_some() -> Option<u8> { // declared as a const function\n    Some(1)\n}\n\nconst FOO: Option<u8> = create_some(); // ok!\n\n// These are also working:\nstruct Bar {\n    x: u8,\n}\n\nconst OTHER_FOO: Option<u8> = Some(1);\nconst BAR: Bar = Bar {x: 1};\n```\n"},"level":"error","spans":[{"file_name":"/build/rustc-1.64.0-src/library/alloc/src/macros.rs","byte_start":1718,"byte_end":1816,"line_start":50,"line_end":53,"column_start":36,"column_end":10,"is_primary":true,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":{"span":{"file_name":"src/lib/card.rs","byte_start":410,"byte_end":526,"line_start":13,"line_end":18,"column_start":37,"column_end":2,"is_primary":false,"text":[{"text":"pub const BIG_RIG: Card = Card::new(vec![","highlight_start":37,"highlight_end":42},{"text":"\t\"         /-/--|\t\t\t\",","highlight_start":1,"highlight_end":23},{"text":"\t\"\t /^\\\\---/_/| +|\t\t\t\",","highlight_start":1,"highlight_end":24},{"text":"\t\" *|#|*/-\\\\__|__|______===_\",","highlight_start":1,"highlight_end":31},{"text":"\t\" ====((O)-----)_)_)((O)(O)\",","highlight_start":1,"highlight_end":31},{"text":"]);","highlight_start":1,"highlight_end":2}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null},"macro_decl_name":"vec!","def_site_span":{"file_name":"/build/rustc-1.64.0-src/library/alloc/src/macros.rs","byte_start":1447,"byte_end":1463,"line_start":42,"line_end":42,"column_start":1,"column_end":17,"is_primary":false,"text":[],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}}}],"children":[{"message":"calls in constants are limited to constant functions, tuple structs and tuple variants","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0015]\u001b[0m\u001b[0m\u001b[1m: cannot call non-const fn `std::slice::<impl [&str]>::into_vec::<std::alloc::Global>` in constants\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/card.rs:13:37\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0mpub const BIG_RIG: Card = Card::new(vec![\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m_____________________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m14\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \"         /-/--|            \",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \"     /^\\\\---/_/| +|            \",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \" *|#|*/-\\\\__|__|______===_\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \" ====((O)-----)_)_)((O)(O)\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m]);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: calls in constants are limited to constant functions, tuple structs and tuple variants\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: this error originates in the macro `vec` (in Nightly builds, run with -Z macro-backtrace for more info)\u001b[0m\n\n"}
{"message":"cannot call non-const fn `Card::new` in constants","code":{"code":"E0015","explanation":"A constant item was initialized with something that is not a constant\nexpression.\n\nErroneous code example:\n\n```compile_fail,E0015\nfn create_some() -> Option<u8> {\n    Some(1)\n}\n\nconst FOO: Option<u8> = create_some(); // error!\n```\n\nThe only functions that can be called in static or constant expressions are\n`const` functions, and struct/enum constructors.\n\nTo fix this error, you can declare `create_some` as a constant function:\n\n```\nconst fn create_some() -> Option<u8> { // declared as a const function\n    Some(1)\n}\n\nconst FOO: Option<u8> = create_some(); // ok!\n\n// These are also working:\nstruct Bar {\n    x: u8,\n}\n\nconst OTHER_FOO: Option<u8> = Some(1);\nconst BAR: Bar = Bar {x: 1};\n```\n"},"level":"error","spans":[{"file_name":"src/lib/card.rs","byte_start":400,"byte_end":527,"line_start":13,"line_end":18,"column_start":27,"column_end":3,"is_primary":true,"text":[{"text":"pub const BIG_RIG: Card = Card::new(vec![","highlight_start":27,"highlight_end":42},{"text":"\t\"         /-/--|\t\t\t\",","highlight_start":1,"highlight_end":23},{"text":"\t\"\t /^\\\\---/_/| +|\t\t\t\",","highlight_start":1,"highlight_end":24},{"text":"\t\" *|#|*/-\\\\__|__|______===_\",","highlight_start":1,"highlight_end":31},{"text":"\t\" ====((O)-----)_)_)((O)(O)\",","highlight_start":1,"highlight_end":31},{"text":"]);","highlight_start":1,"highlight_end":3}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"calls in constants are limited to constant functions, tuple structs and tuple variants","code":null,"level":"note","spans":[],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror[E0015]\u001b[0m\u001b[0m\u001b[1m: cannot call non-const fn `Card::new` in constants\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/card.rs:13:27\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m13\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0mpub const BIG_RIG: Card = Card::new(vec![\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m___________________________^\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m14\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \"         /-/--|            \",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m15\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \"     /^\\\\---/_/| +|            \",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m16\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \" *|#|*/-\\\\__|__|______===_\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m17\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    \" ====((O)-----)_)_)((O)(O)\",\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m18\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m]);\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|__^\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: calls in constants are limited to constant functions, tuple structs and tuple variants\u001b[0m\n\n"}
{"message":"lifetime may not live long enough","code":null,"level":"error","spans":[{"file_name":"src/lib/card.rs","byte_start":567,"byte_end":568,"line_start":21,"line_end":21,"column_start":22,"column_end":23,"is_primary":false,"text":[{"text":"\tpub fn new(art: Vec<&str>) -> Self {","highlight_start":22,"highlight_end":23}],"label":"let's call the lifetime of this reference `'1`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib/card.rs","byte_start":577,"byte_end":581,"line_start":21,"line_end":21,"column_start":32,"column_end":36,"is_primary":false,"text":[{"text":"\tpub fn new(art: Vec<&str>) -> Self {","highlight_start":32,"highlight_end":36}],"label":"return type is Card<'2>","suggested_replacement":null,"suggestion_applicability":null,"expansion":null},{"file_name":"src/lib/card.rs","byte_start":730,"byte_end":766,"line_start":30,"line_end":34,"column_start":3,"column_end":4,"is_primary":true,"text":[{"text":"\t\tCard {","highlight_start":3,"highlight_end":9},{"text":"\t\t\trows,","highlight_start":1,"highlight_end":9},{"text":"\t\t\tcols,","highlight_start":1,"highlight_end":9},{"text":"\t\t\tart,","highlight_start":1,"highlight_end":8},{"text":"\t\t}","highlight_start":1,"highlight_end":4}],"label":"associated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`","suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: lifetime may not live long enough\u001b[0m\n\u001b[0m  \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/lib/card.rs:30:3\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m21\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m   \u001b[0m\u001b[0m    pub fn new(art: Vec<&str>) -> Self {\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m-\u001b[0m\u001b[0m         \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mreturn type is Card<'2>\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m                          \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mlet's call the lifetime of this reference `'1`\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m...\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m30\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m/\u001b[0m\u001b[0m \u001b[0m\u001b[0m        Card {\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m31\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            rows,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m32\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            cols,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m33\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m            art,\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m34\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m        }\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9m|_________^\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;9massociated function was supposed to return data with lifetime `'2` but it is returning data with lifetime `'1`\u001b[0m\n\n"}
{"message":"variable does not need to be mutable","code":{"code":"unused_mut","explanation":null},"level":"warning","spans":[{"file_name":"src/main.rs","byte_start":11116,"byte_end":11130,"line_start":336,"line_end":336,"column_start":9,"column_end":23,"is_primary":true,"text":[{"text":"    let mut user_entry: Option<char> = get_instant_input(&['y', 'n']);","highlight_start":9,"highlight_end":23}],"label":null,"suggested_replacement":null,"suggestion_applicability":null,"expansion":null}],"children":[{"message":"`#[warn(unused_mut)]` on by default","code":null,"level":"note","spans":[],"children":[],"rendered":null},{"message":"remove this `mut`","code":null,"level":"help","spans":[{"file_name":"src/main.rs","byte_start":11116,"byte_end":11120,"line_start":336,"line_end":336,"column_start":9,"column_end":13,"is_primary":true,"text":[{"text":"    let mut user_entry: Option<char> = get_instant_input(&['y', 'n']);","highlight_start":9,"highlight_end":13}],"label":null,"suggested_replacement":"","suggestion_applicability":"MachineApplicable","expansion":null}],"children":[],"rendered":null}],"rendered":"\u001b[0m\u001b[1m\u001b[33mwarning\u001b[0m\u001b[0m\u001b[1m: variable does not need to be mutable\u001b[0m\n\u001b[0m   \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m--> \u001b[0m\u001b[0msrc/main.rs:336:9\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m\u001b[1m\u001b[38;5;12m336\u001b[0m\u001b[0m \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\u001b[0m \u001b[0m\u001b[0m    let mut user_entry: Option<char> = get_instant_input(&['y', 'n']);\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m----\u001b[0m\u001b[0m\u001b[1m\u001b[33m^^^^^^^^^^\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m| \u001b[0m\u001b[0m        \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12mhelp: remove this `mut`\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m|\u001b[0m\n\u001b[0m    \u001b[0m\u001b[0m\u001b[1m\u001b[38;5;12m= \u001b[0m\u001b[0m\u001b[1mnote\u001b[0m\u001b[0m: `#[warn(unused_mut)]` on by default\u001b[0m\n\n"}
{"message":"aborting due to 16 previous errors; 14 warnings emitted","code":null,"level":"error","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1m\u001b[38;5;9merror\u001b[0m\u001b[0m\u001b[1m: aborting due to 16 previous errors; 14 warnings emitted\u001b[0m\n\n"}
{"message":"Some errors have detailed explanations: E0010, E0015.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mSome errors have detailed explanations: E0010, E0015.\u001b[0m\n"}
{"message":"For more information about an error, try `rustc --explain E0010`.","code":null,"level":"failure-note","spans":[],"children":[],"rendered":"\u001b[0m\u001b[1mFor more information about an error, try `rustc --explain E0010`.\u001b[0m\n"}
